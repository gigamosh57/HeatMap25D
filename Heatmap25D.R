# Generates a 2-D heatmap of with 1-D heatmaps on each of the X and Y axes
# Pass xdata and ydata as individual columns of equally sized data

# TODO:
#  Select bin boundaries
#  Debug plot so it works if there are values outside of bin boundaries
# 


Heatmap25D <- function(xdata, ydata, xname, yname, xbins = NA, ybins = NA,xbins.n = 50, ybins.n = 50, main ="") {

  require(ggplot2)
  require(plyr)
  require(scales) 
  require(grid)
  require(reshape)
  
  # round data for summarization
  x.range <- c(min(xdata),max(xdata))
  y.range <- c(min(ydata),max(ydata))

  # set num bins to be a maximum of unique x or xbins
  x.bins.plot = min(xbins.n, length(unique(xdata)))
  x.bins <- seq(x.range[1],x.range[2],length.out=x.bins.plot)
  
  # set num bins to be a maximum of unique y or ybins
  y.bins.plot = min(ybins.n, length(unique(ydata)))
  y.bins <- seq(y.range[1],y.range[2],length.out=y.bins.plot) 
  
  # Use set thresholds if provided
  if(is.na(xbins[1])){
    # this uses bins generated by the max number
    
    # Use findInterval to snap values to within a bin
    x.data.binned <- x.bins[findInterval(xdata, x.bins)]
  }else{
    # this uses bins provided by user
    
    # round all values above the highest bin to the highest bin
    xdata[which(xdata > max(xbins))] <- max(xbins)
    # same with lower bound
    xdata[which(xdata < min(xbins))] <- min(xbins)
    
    x.data.binned <- xbins[findInterval(xdata, xbins)]
  }
  
  if(is.na(ybins[1])){
    # this uses bins generated by the max number
    
    # Use findInterval to snap values to within a bin
    y.data.binned <- y.bins[findInterval(ydata, y.bins)]  
  }else{
    # this uses bins provided by user
    
    # round all values above the highest bin to the highest bin
    ydata[which(ydata > max(ybins))] <- max(ybins)
    # same with lower bound
    ydata[which(ydata < min(ybins))] <- min(ybins)
    
    y.data.binned <- ybins[findInterval(ydata, ybins)]
  }
  
  data.heat <- data.frame(x.heat = x.data.binned, y.heat = y.data.binned)
  
  # Prep data (count vs mean)
  
  # performs aggregation for total response
  sd = count(data.heat,c("x.heat","y.heat"))
  
  # calc total by x.heat
  x.summ <- count(data.heat,c("x.heat")) 
  
  # calc total by y.heat bin
  y.summ <- count(data.heat,c("y.heat")) 
  
  # calc Total overall
  total <- data.frame(freq = length(data.heat[,1])) 
  
  # OUTPUT TO PLOTS
  plotdata = sd[,c("x.heat","y.heat","freq")]
  
  # Generate heatmap
  
  # to make scale continuous    
  plotdata.s <- plotdata
  plotdata.s$rescale <- rescale(plotdata.s$freq)
  
  x.summ$rescale <- rescale(x.summ$freq)
  y.summ$rescale <- rescale(y.summ$freq)
  
  #gradient color controls
  xycol = c("grey","blue")
  xcol = c("grey","darkorange2")
  ycol = c("grey","firebrick3")
  
  pttl <-  ggplot() + 
    ggtitle(main)
  
  pxy <- ggplot(plotdata.s, aes(x = x.heat, y = y.heat,fill=rescale)) + 
    geom_raster() +
    scale_fill_gradientn(colors = xycol,
                         oob      = identity,guide=FALSE) +       
    
    geom_text(data=plotdata.s, aes(label = ifelse((is.na(freq)),"",round(freq,1))), col="white") + 
    
    theme(
      axis.text.x = element_blank(),
      axis.title.x = element_blank(),
      axis.text.y = element_blank(),
      axis.title.y = element_blank(),
      axis.ticks.y = element_blank(),
      axis.ticks.x = element_blank(),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      panel.border = element_blank(),
      panel.background = element_blank())
  
  px <- ggplot(x.summ, aes(y = 1, x = x.heat)) + 
    geom_tile(aes(fill = rescale)) +
    scale_fill_gradientn(colors = xcol,
                         oob      = identity,guide=FALSE) +       
    
    geom_text(data=x.summ, aes(x = x.heat, y = 1,label = ifelse((is.na(freq)),"",round(freq,1))), col="white") + 
    
    labs(x=xname) + 
    
    theme(
      axis.ticks.y = element_blank(),
      axis.text.y = element_blank(),
      axis.title.y = element_blank(),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      panel.border = element_blank(),
      panel.background = element_blank())
  
  py <- ggplot(y.summ, aes(x = 1, y = y.heat)) + 
    geom_tile(aes(fill = rescale)) +
    scale_fill_gradientn(colors = ycol,
                         oob      = identity,guide=FALSE) +       
    
    geom_text(data=y.summ, aes(x = 1,y = y.heat,label = ifelse((is.na(freq)),"",round(freq,1))), col="white") + 
    
    labs(y=yname) + 
    
    theme(
      axis.ticks.x = element_blank(),
      axis.text.x = element_blank(),
      axis.title.x = element_blank(),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      panel.border = element_blank(),
      panel.background = element_blank())
  
  
  layt<-grid.layout(nrow=3,ncol=2,heights=c(1/16, 13/16,2/16),widths=c(3/16,13/16),default.units=c('null','null'))
  #View the layout of plots
  grid.show.layout(layt)
  
  #Draw plots one by one in their positions
  grid.newpage()
  pushViewport(viewport(layout=layt))
  print(pttl,vp=viewport(layout.pos.row=1,layout.pos.col=2))
  print(py,vp=viewport(layout.pos.row=2,layout.pos.col=1))
  print(pxy,vp=viewport(layout.pos.row=2,layout.pos.col=2))
  print(px,vp=viewport(layout.pos.row=3,layout.pos.col=2))
}